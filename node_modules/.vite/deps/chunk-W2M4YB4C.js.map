{
  "version": 3,
  "sources": ["../../.pnpm/@alova+shared@1.3.1/node_modules/@alova/shared/dist/alova-shared.esm.js"],
  "sourcesContent": ["/**\n  * @alova/shared 1.3.1 (https://alova.js.org)\n  * Document https://alova.js.org\n  * Copyright 2025 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://github.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nconst undefStr = 'undefined';\n// The following unified processing functions or variables added to reduce the amount of compiled code\nconst PromiseCls = Promise;\nconst promiseResolve = (value) => PromiseCls.resolve(value);\nconst promiseReject = (value) => PromiseCls.reject(value);\nconst ObjectCls = Object;\nconst RegExpCls = RegExp;\nconst undefinedValue = undefined;\nconst nullValue = null;\nconst trueValue = true;\nconst falseValue = false;\nconst promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);\nconst promiseCatch = (promise, onrejected) => promise.catch(onrejected);\nconst promiseFinally = (promise, onfinally) => promise.finally(onfinally);\nconst promiseAll = (values) => PromiseCls.all(values);\nconst JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);\nconst JSONParse = (value) => JSON.parse(value);\nconst setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);\nconst clearTimeoutTimer = (timer) => clearTimeout(timer);\nconst objectKeys = (obj) => ObjectCls.keys(obj);\nconst objectValues = (obj) => ObjectCls.values(obj);\nconst forEach = (ary, fn) => ary.forEach(fn);\nconst pushItem = (ary, ...item) => ary.push(...item);\nconst mapItem = (ary, callbackfn) => ary.map(callbackfn);\nconst filterItem = (ary, predicate) => ary.filter(predicate);\nconst shift = (ary) => ary.shift();\nconst slice = (ary, start, end) => ary.slice(start, end);\nconst splice = (ary, start, deleteCount = 0, ...items) => ary.splice(start, deleteCount, ...items);\nconst len = (data) => data.length;\nconst isArray = (arg) => Array.isArray(arg);\nconst deleteAttr = (arg, attr) => delete arg[attr];\nconst typeOf = (arg) => typeof arg;\nconst regexpTest = (reg, str) => reg.test(`${str}`);\nconst includes = (ary, target) => ary.includes(target);\nconst valueObject = (value, writable = falseValue) => ({ value, writable });\nconst defineProperty = (o, key, value, isDescriptor = falseValue) => ObjectCls.defineProperty(o, key, isDescriptor ? value : valueObject(value, falseValue));\n// Whether it is running on the server side, node and bun are judged by process, and deno is judged by Deno.\n// Some frameworks (such as Alipay and uniapp) will inject the process object as a global variable which `browser` is true\nconst isSSR = typeof window === undefStr && (typeof process !== undefStr ? !process.browser : typeof Deno !== undefStr);\n/** cache mode */\n// only cache in memory, it's default option\nconst MEMORY = 'memory';\n// persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.\nconst STORAGE_RESTORE = 'restore';\n\n/**\n * Empty function for compatibility processing\n */\nconst noop = () => { };\n/**\n * A function that returns the parameter itself, used for compatibility processing\n * Since some systems use self as a reserved word, $self is used to distinguish it.\n * @param arg any parameter\n * @returns return parameter itself\n */\nconst $self = (arg) => arg;\n/**\n * Determine whether the parameter is a function any parameter\n * @returns Whether the parameter is a function\n */\nconst isFn = (arg) => typeOf(arg) === 'function';\n/**\n * Determine whether the parameter is a number any parameter\n * @returns Whether the parameter is a number\n */\nconst isNumber = (arg) => typeOf(arg) === 'number' && !Number.isNaN(arg);\n/**\n * Determine whether the parameter is a string any parameter\n * @returns Whether the parameter is a string\n */\nconst isString = (arg) => typeOf(arg) === 'string';\n/**\n * Determine whether the parameter is an object any parameter\n * @returns Whether the parameter is an object\n */\nconst isObject = (arg) => arg !== nullValue && typeOf(arg) === 'object';\n/**\n * Global toString any parameter stringified parameters\n */\nconst globalToString = (arg) => ObjectCls.prototype.toString.call(arg);\n/**\n * Determine whether it is a normal object any parameter\n * @returns Judgment result\n */\nconst isPlainObject = (arg) => globalToString(arg) === '[object Object]';\n/**\n * Determine whether it is an instance of a certain class any parameter\n * @returns Judgment result\n */\nconst instanceOf = (arg, cls) => arg instanceof cls;\n/**\n * Unified timestamp acquisition function\n * @returns Timestamp\n */\nconst getTime = (date) => (date ? date.getTime() : Date.now());\n/**\n * Get the alova instance through the method instance alova example\n */\nconst getContext = (methodInstance) => methodInstance.context;\n/**\n * Get method instance configuration data\n * @returns Configuration object\n */\nconst getConfig = (methodInstance) => methodInstance.config;\n/**\n * Get alova configuration data alova configuration object\n */\nconst getContextOptions = (alovaInstance) => alovaInstance.options;\n/**\n * Get alova configuration data through method instance alova configuration object\n */\nconst getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));\n/**\n * Get the key value of the request method\n * @returns The key value of this request method\n */\nconst key = (methodInstance) => {\n    const { params, headers } = getConfig(methodInstance);\n    return JSONStringify([methodInstance.type, methodInstance.url, params, methodInstance.data, headers]);\n};\n/**\n * Create uuid simple version uuid\n */\nconst uuid = () => {\n    const timestamp = new Date().getTime();\n    return Math.floor(Math.random() * timestamp).toString(36);\n};\n/**\n * Get the key value of the method instance method instance\n * @returns The key value of this method instance\n */\nconst getMethodInternalKey = (methodInstance) => methodInstance.key;\n/**\n * Get the request method object\n * @param methodHandler Request method handle\n * @param args Method call parameters request method object\n */\nconst getHandlerMethod = (methodHandler, assert, args = []) => {\n    const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;\n    assert(!!methodInstance.key, 'hook handler must be a method instance or a function that returns method instance');\n    return methodInstance;\n};\n/**\n * Is it special data\n * @param data Submit data\n * @returns Judgment result\n */\nconst isSpecialRequestBody = (data) => {\n    const dataTypeString = globalToString(data);\n    return (/^\\[object (Blob|FormData|ReadableStream|URLSearchParams)\\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer));\n};\nconst objAssign = (target, ...sources) => ObjectCls.assign(target, ...sources);\n/**\n * Excludes specified attributes from a data collection and returns a new data collection data collection\n * @param keys Excluded keys new data collection\n */\nconst omit = (obj, ...keys) => {\n    const result = {};\n    for (const key in obj) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n};\n/**\n * the same as `Promise.withResolvers`\n * @returns promise with resolvers.\n */\nfunction usePromise() {\n    let retResolve;\n    let retReject;\n    const promise = new Promise((resolve, reject) => {\n        retResolve = resolve;\n        retReject = reject;\n    });\n    return { promise, resolve: retResolve, reject: retReject };\n}\n/**\n * Get cached configuration parameters, fixedly returning an object in the format { e: function, c: any, f: any, m: number, s: boolean, t: string } e is the abbreviation of expire, which returns the cache expiration time point (timestamp) in milliseconds.\n * c is controlled, indicating whether it is a controlled cache\n * f is the original value of cacheFor, which is used to call to obtain cached data when c is true.\n * m is the abbreviation of mode, storage mode\n * s is the abbreviation of storage, whether to store it locally\n * t is the abbreviation of tag, which stores tags persistently.\n * @param methodInstance method instance\n * @returns Unified cache parameter object\n */\nconst getLocalCacheConfigParam = (methodInstance) => {\n    const { cacheFor } = getConfig(methodInstance);\n    const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue);\n    let cacheMode = MEMORY;\n    let expire = () => 0;\n    let store = falseValue;\n    let tag = undefinedValue;\n    const controlled = isFn(cacheFor);\n    if (!controlled) {\n        let expireColumn = cacheFor;\n        if (isPlainObject(cacheFor)) {\n            const { mode = MEMORY, expire, tag: configTag } = cacheFor || {};\n            cacheMode = mode;\n            store = mode === STORAGE_RESTORE;\n            tag = configTag ? configTag.toString() : undefinedValue;\n            expireColumn = expire;\n        }\n        expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);\n    }\n    return {\n        f: cacheFor,\n        c: controlled,\n        e: expire,\n        m: cacheMode,\n        s: store,\n        t: tag\n    };\n};\n/**\n * Create class instance\n * @param Cls Constructor\n * @param args Constructor parameters class instance\n */\nconst newInstance = (Cls, ...args) => new Cls(...args);\n/**\n * Unified configuration\n * @param data\n * @returns unified configuration\n */\nconst sloughConfig = (config, args = []) => isFn(config) ? config(...args) : config;\nconst sloughFunction = (arg, defaultFn) => isFn(arg) ? arg : ![falseValue, nullValue].includes(arg) ? defaultFn : noop;\n/**\n * Create an executor that calls multiple times synchronously and only executes it once asynchronously\n */\nconst createSyncOnceRunner = (delay = 0) => {\n    let timer = undefinedValue;\n    // Executing multiple calls to this function will execute once asynchronously\n    return (fn) => {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeoutFn(fn, delay);\n    };\n};\n/**\n * Create an asynchronous function queue, the asynchronous function will be executed serially queue add function\n */\nconst createAsyncQueue = (catchError = falseValue) => {\n    const queue = [];\n    let completedHandler = undefinedValue;\n    let executing = false;\n    const executeQueue = async () => {\n        executing = trueValue;\n        while (len(queue) > 0) {\n            const asyncFunc = shift(queue);\n            if (asyncFunc) {\n                await asyncFunc();\n            }\n        }\n        completedHandler && completedHandler();\n        executing = falseValue;\n    };\n    const addQueue = (asyncFunc) => newInstance((PromiseCls), (resolve, reject) => {\n        const wrappedFunc = () => promiseThen(asyncFunc(), resolve, err => {\n            catchError ? resolve(undefinedValue) : reject(err);\n        });\n        pushItem(queue, wrappedFunc);\n        if (!executing) {\n            executeQueue();\n        }\n    });\n    const onComplete = (fn) => {\n        completedHandler = fn;\n    };\n    return {\n        addQueue,\n        onComplete\n    };\n};\n/**\n * Traverse the target object deeply target audience\n * @param callback Traversal callback\n * @param preorder Whether to traverse in preorder, the default is true\n * @param key The currently traversed key\n * @param parent The parent node currently traversed\n */\nconst walkObject = (target, callback, preorder = trueValue, key, parent) => {\n    const callCallback = () => {\n        if (parent && key) {\n            target = callback(target, key, parent);\n            if (target !== parent[key]) {\n                parent[key] = target;\n            }\n        }\n    };\n    // Preorder traversal\n    preorder && callCallback();\n    if (isObject(target)) {\n        for (const i in target) {\n            if (!instanceOf(target, String)) {\n                walkObject(target[i], callback, preorder, i, target);\n            }\n        }\n    }\n    // Postal order traversal\n    !preorder && callCallback();\n    return target;\n};\nconst cacheKeyPrefix = '$a.';\n/**\n * build common cache key.\n */\nconst buildNamespacedCacheKey = (namespace, key) => cacheKeyPrefix + namespace + key;\n/**\n * Calculate retry delay time based on avoidance strategy and number of retries avoid parameters\n * @param retryTimes Number of retries\n * @returns Retry delay time\n */\nconst delayWithBackoff = (backoff, retryTimes) => {\n    let { startQuiver, endQuiver } = backoff;\n    const { delay, multiplier = 1 } = backoff;\n    let retryDelayFinally = (delay || 0) * multiplier ** (retryTimes - 1);\n    // If start quiver or end quiver has a value, you need to increase the random jitter value in the specified range\n    if (startQuiver || endQuiver) {\n        startQuiver = startQuiver || 0;\n        endQuiver = endQuiver || 1;\n        retryDelayFinally +=\n            retryDelayFinally * startQuiver + Math.random() * retryDelayFinally * (endQuiver - startQuiver);\n        retryDelayFinally = Math.floor(retryDelayFinally); // round delay\n    }\n    return retryDelayFinally;\n};\n/**\n * Build the complete url baseURL path url parameters complete url\n */\nconst buildCompletedURL = (baseURL, url, params) => {\n    // Check if the URL starts with http/https\n    const startsWithPrefix = /^https?:\\/\\//i.test(url);\n    if (!startsWithPrefix) {\n        // If the Base url ends with /, remove /\n        baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;\n        // If it does not start with /or http protocol, you need to add /\n        // Compatible with some RESTful usage fix: https://github.com/alovajs/alova/issues/382\n        if (url !== '') {\n            // Since absolute URLs (http/https) are handled above,\n            // we only need to ensure relative URLs start with a forward slash\n            url = url.startsWith('/') ? url : `/${url}`;\n        }\n    }\n    // fix: https://github.com/alovajs/alova/issues/653\n    const completeURL = startsWithPrefix ? url : baseURL + url;\n    // Convert params object to get string\n    // Filter out those whose value is undefined\n    const paramsStr = isString(params)\n        ? params\n        : mapItem(filterItem(objectKeys(params), key => params[key] !== undefinedValue), key => `${key}=${params[key]}`).join('&');\n    // Splice the get parameters behind the url. Note that the url may already have parameters.\n    return paramsStr\n        ? +completeURL.includes('?')\n            ? `${completeURL}&${paramsStr}`\n            : `${completeURL}?${paramsStr}`\n        : completeURL;\n};\n/**\n * Deep clone an object.\n *\n * @param obj The object to be cloned.\n * @returns The cloned object.\n */\nconst deepClone = (obj) => {\n    if (isArray(obj)) {\n        return mapItem(obj, deepClone);\n    }\n    if (isPlainObject(obj) && obj.constructor === ObjectCls) {\n        const clone = {};\n        forEach(objectKeys(obj), key => {\n            clone[key] = deepClone(obj[key]);\n        });\n        return clone;\n    }\n    return obj;\n};\n\n/**\n * alova error class\n */\nclass AlovaError extends Error {\n    constructor(prefix, message, errorCode) {\n        super(message + (errorCode ? `\\n\\nFor detailed: https://alova.js.org/error#${errorCode}` : ''));\n        this.name = `[alova${prefix ? `/${prefix}` : ''}]`;\n    }\n}\n/**\n * Custom assertion function that throws an error when the expression is false\n * When errorCode is passed in, a link to the error document will be provided to guide the user to correct it.\n * @param expression Judgment expression, true or false\n * @param message Assert message\n */\nconst createAssert = (prefix = '') => (expression, message, errorCode) => {\n    if (!expression) {\n        throw newInstance(AlovaError, prefix, message, errorCode);\n    }\n};\n\nconst bridgeObject = JSON.parse;\n/**\n * Injects a reference object with `JSON.parse` so that it can be accessed in another module.\n * @param object injecting object\n */\nconst provideReferingObject = (object) => {\n    bridgeObject.bridgeData = object;\n};\nconst injectReferingObject = () => (bridgeObject.bridgeData || {});\n\nconst createEventManager = () => {\n    const eventMap = {};\n    return {\n        eventMap,\n        on(type, handler) {\n            const eventTypeItem = (eventMap[type] = eventMap[type] || []);\n            pushItem(eventTypeItem, handler);\n            // return the off function\n            return () => {\n                eventMap[type] = filterItem(eventTypeItem, item => item !== handler);\n            };\n        },\n        off(type, handler) {\n            const handlers = eventMap[type];\n            if (!handlers) {\n                return;\n            }\n            if (handler) {\n                const index = handlers.indexOf(handler);\n                index > -1 && handlers.splice(index, 1);\n            }\n            else {\n                delete eventMap[type];\n            }\n        },\n        emit(type, event) {\n            const handlers = eventMap[type] || [];\n            return mapItem(handlers, handler => handler(event));\n        }\n    };\n};\nconst decorateEvent = (onEvent, decoratedHandler) => {\n    const emitter = createEventManager();\n    const eventType = uuid();\n    const eventReturn = onEvent(event => emitter.emit(eventType, event));\n    return (handler) => {\n        emitter.on(eventType, event => {\n            decoratedHandler(handler, event);\n        });\n        return eventReturn;\n    };\n};\n\nclass FrameworkReadableState {\n    constructor(state, key, dehydrate, exportState) {\n        this.s = state;\n        this.k = key;\n        this.$dhy = dehydrate;\n        this.$exp = exportState;\n    }\n    get v() {\n        return this.$dhy(this.s);\n    }\n    get e() {\n        return this.$exp(this.s);\n    }\n}\nclass FrameworkState extends FrameworkReadableState {\n    constructor(state, key, dehydrate, exportState, update) {\n        super(state, key, dehydrate, exportState);\n        this.$upd = update;\n    }\n    set v(newValue) {\n        this.$upd(this.s, newValue);\n    }\n    get v() {\n        return this.$dhy(this.s);\n    }\n}\n\nclass QueueCallback {\n    /**\n     * @param [limit=null] no limit if set undefined or null\n     * @param [initialProcessing=false]\n     */\n    constructor(limit, initialProcessing = false) {\n        this.limit = limit;\n        this.callbackQueue = [];\n        this.isProcessing = false;\n        this.interrupt = false;\n        this.isProcessing = initialProcessing;\n    }\n    /**\n     * Adds a callback function to the callback queue.\n     * If a limit is set and the queue has reached its limit, the callback will not be added.\n     * @param callback The callback function to be added to the queue.\n     */\n    queueCallback(callback) {\n        if (this.limit && this.callbackQueue.length >= this.limit) {\n            return;\n        }\n        this.callbackQueue.push(callback);\n        if (!this.isProcessing) {\n            this.tryRunQueueCallback();\n        }\n    }\n    /**\n     * Tries to run the callbacks in the queue.\n     * If there are callbacks in the queue, it removes the first callback and executes it.\n     * This method is called recursively until there are no more callbacks in the queue.\n     */\n    async tryRunQueueCallback() {\n        this.isProcessing = true;\n        this.interrupt = false;\n        while (this.callbackQueue.length > 0 && !this.interrupt) {\n            const cb = this.callbackQueue.shift();\n            await (cb === null || cb === void 0 ? void 0 : cb());\n        }\n        this.isProcessing = false;\n    }\n    /**\n     * If set the param `state` to true, it will interrupt the current job (whether or not the current processing state is true)\n     * If set the param `state` to false, then get on with the rest of the work\n     */\n    setProcessingState(state) {\n        this.isProcessing = state;\n        if (!state) {\n            this.tryRunQueueCallback();\n        }\n        else {\n            this.interrupt = true;\n        }\n    }\n}\n\nconst type = {};\n\nexport { $self, AlovaError, FrameworkReadableState, FrameworkState, JSONParse, JSONStringify, MEMORY, ObjectCls, PromiseCls, QueueCallback, RegExpCls, STORAGE_RESTORE, buildCompletedURL, buildNamespacedCacheKey, clearTimeoutTimer, createAssert, createAsyncQueue, createEventManager, createSyncOnceRunner, decorateEvent, deepClone, defineProperty, delayWithBackoff, deleteAttr, falseValue, filterItem, forEach, getConfig, getContext, getContextOptions, getHandlerMethod, getLocalCacheConfigParam, getMethodInternalKey, getOptions, getTime, globalToString, includes, injectReferingObject, instanceOf, isArray, isFn, isNumber, isObject, isPlainObject, isSSR, isSpecialRequestBody, isString, key, len, mapItem, newInstance, noop, nullValue, objAssign, objectKeys, objectValues, omit, promiseAll, promiseCatch, promiseFinally, promiseReject, promiseResolve, promiseThen, provideReferingObject, pushItem, regexpTest, setTimeoutFn, shift, slice, sloughConfig, sloughFunction, splice, trueValue, type, typeOf, undefinedValue, usePromise, uuid, valueObject, walkObject };\n"],
  "mappings": "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",
  "names": ["expire", "key", "key"]
}
