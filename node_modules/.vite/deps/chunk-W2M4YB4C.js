// node_modules/.pnpm/@alova+shared@1.3.1/node_modules/@alova/shared/dist/alova-shared.esm.js
var undefStr = "undefined";
var PromiseCls = Promise;
var promiseResolve = (value) => PromiseCls.resolve(value);
var promiseReject = (value) => PromiseCls.reject(value);
var ObjectCls = Object;
var RegExpCls = RegExp;
var undefinedValue = void 0;
var nullValue = null;
var trueValue = true;
var falseValue = false;
var promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);
var promiseCatch = (promise, onrejected) => promise.catch(onrejected);
var promiseFinally = (promise, onfinally) => promise.finally(onfinally);
var JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);
var JSONParse = (value) => JSON.parse(value);
var setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);
var clearTimeoutTimer = (timer) => clearTimeout(timer);
var objectKeys = (obj) => ObjectCls.keys(obj);
var forEach = (ary, fn) => ary.forEach(fn);
var pushItem = (ary, ...item) => ary.push(...item);
var mapItem = (ary, callbackfn) => ary.map(callbackfn);
var filterItem = (ary, predicate) => ary.filter(predicate);
var len = (data) => data.length;
var isArray = (arg) => Array.isArray(arg);
var deleteAttr = (arg, attr) => delete arg[attr];
var typeOf = (arg) => typeof arg;
var isSSR = typeof window === undefStr && (typeof process !== undefStr ? !process.browser : typeof Deno !== undefStr);
var MEMORY = "memory";
var STORAGE_RESTORE = "restore";
var noop = () => {
};
var $self = (arg) => arg;
var isFn = (arg) => typeOf(arg) === "function";
var isNumber = (arg) => typeOf(arg) === "number" && !Number.isNaN(arg);
var isString = (arg) => typeOf(arg) === "string";
var globalToString = (arg) => ObjectCls.prototype.toString.call(arg);
var isPlainObject = (arg) => globalToString(arg) === "[object Object]";
var instanceOf = (arg, cls) => arg instanceof cls;
var getTime = (date) => date ? date.getTime() : Date.now();
var getContext = (methodInstance) => methodInstance.context;
var getConfig = (methodInstance) => methodInstance.config;
var getContextOptions = (alovaInstance) => alovaInstance.options;
var getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));
var key = (methodInstance) => {
  const { params, headers } = getConfig(methodInstance);
  return JSONStringify([methodInstance.type, methodInstance.url, params, methodInstance.data, headers]);
};
var getMethodInternalKey = (methodInstance) => methodInstance.key;
var isSpecialRequestBody = (data) => {
  const dataTypeString = globalToString(data);
  return /^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer);
};
var objAssign = (target, ...sources) => ObjectCls.assign(target, ...sources);
function usePromise() {
  let retResolve;
  let retReject;
  const promise = new Promise((resolve, reject) => {
    retResolve = resolve;
    retReject = reject;
  });
  return { promise, resolve: retResolve, reject: retReject };
}
var getLocalCacheConfigParam = (methodInstance) => {
  const { cacheFor } = getConfig(methodInstance);
  const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue);
  let cacheMode = MEMORY;
  let expire = () => 0;
  let store = falseValue;
  let tag = undefinedValue;
  const controlled = isFn(cacheFor);
  if (!controlled) {
    let expireColumn = cacheFor;
    if (isPlainObject(cacheFor)) {
      const { mode = MEMORY, expire: expire2, tag: configTag } = cacheFor || {};
      cacheMode = mode;
      store = mode === STORAGE_RESTORE;
      tag = configTag ? configTag.toString() : undefinedValue;
      expireColumn = expire2;
    }
    expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);
  }
  return {
    f: cacheFor,
    c: controlled,
    e: expire,
    m: cacheMode,
    s: store,
    t: tag
  };
};
var newInstance = (Cls, ...args) => new Cls(...args);
var sloughFunction = (arg, defaultFn) => isFn(arg) ? arg : ![falseValue, nullValue].includes(arg) ? defaultFn : noop;
var cacheKeyPrefix = "$a.";
var buildNamespacedCacheKey = (namespace, key2) => cacheKeyPrefix + namespace + key2;
var buildCompletedURL = (baseURL, url, params) => {
  const startsWithPrefix = /^https?:\/\//i.test(url);
  if (!startsWithPrefix) {
    baseURL = baseURL.endsWith("/") ? baseURL.slice(0, -1) : baseURL;
    if (url !== "") {
      url = url.startsWith("/") ? url : `/${url}`;
    }
  }
  const completeURL = startsWithPrefix ? url : baseURL + url;
  const paramsStr = isString(params) ? params : mapItem(filterItem(objectKeys(params), (key2) => params[key2] !== undefinedValue), (key2) => `${key2}=${params[key2]}`).join("&");
  return paramsStr ? +completeURL.includes("?") ? `${completeURL}&${paramsStr}` : `${completeURL}?${paramsStr}` : completeURL;
};
var deepClone = (obj) => {
  if (isArray(obj)) {
    return mapItem(obj, deepClone);
  }
  if (isPlainObject(obj) && obj.constructor === ObjectCls) {
    const clone = {};
    forEach(objectKeys(obj), (key2) => {
      clone[key2] = deepClone(obj[key2]);
    });
    return clone;
  }
  return obj;
};
var AlovaError = class extends Error {
  constructor(prefix, message, errorCode) {
    super(message + (errorCode ? `

For detailed: https://alova.js.org/error#${errorCode}` : ""));
    this.name = `[alova${prefix ? `/${prefix}` : ""}]`;
  }
};
var createAssert = (prefix = "") => (expression, message, errorCode) => {
  if (!expression) {
    throw newInstance(AlovaError, prefix, message, errorCode);
  }
};
var createEventManager = () => {
  const eventMap = {};
  return {
    eventMap,
    on(type, handler) {
      const eventTypeItem = eventMap[type] = eventMap[type] || [];
      pushItem(eventTypeItem, handler);
      return () => {
        eventMap[type] = filterItem(eventTypeItem, (item) => item !== handler);
      };
    },
    off(type, handler) {
      const handlers = eventMap[type];
      if (!handlers) {
        return;
      }
      if (handler) {
        const index = handlers.indexOf(handler);
        index > -1 && handlers.splice(index, 1);
      } else {
        delete eventMap[type];
      }
    },
    emit(type, event) {
      const handlers = eventMap[type] || [];
      return mapItem(handlers, (handler) => handler(event));
    }
  };
};

export {
  PromiseCls,
  promiseResolve,
  promiseReject,
  ObjectCls,
  RegExpCls,
  undefinedValue,
  trueValue,
  falseValue,
  promiseThen,
  promiseCatch,
  promiseFinally,
  JSONStringify,
  JSONParse,
  setTimeoutFn,
  clearTimeoutTimer,
  objectKeys,
  forEach,
  pushItem,
  mapItem,
  filterItem,
  len,
  isArray,
  deleteAttr,
  isSSR,
  MEMORY,
  STORAGE_RESTORE,
  noop,
  $self,
  isFn,
  isNumber,
  isString,
  globalToString,
  isPlainObject,
  instanceOf,
  getTime,
  getContext,
  getConfig,
  getContextOptions,
  getOptions,
  key,
  getMethodInternalKey,
  isSpecialRequestBody,
  objAssign,
  usePromise,
  getLocalCacheConfigParam,
  newInstance,
  sloughFunction,
  buildNamespacedCacheKey,
  buildCompletedURL,
  deepClone,
  createAssert,
  createEventManager
};
//# sourceMappingURL=chunk-W2M4YB4C.js.map
